#version 460
#extension GL_EXT_debug_printf : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=0, binding = 0, r32f) readonly uniform image2DArray input_f;
layout(set=0, binding = 1, r32f) writeonly uniform image2DArray output_f;

layout(push_constant) uniform PushConstants {
    bool init;
} push_constants;

const int N = 9;

const ivec2 c[9] = {
    ivec2(0,0),
    ivec2(1,0),
    ivec2(0,1),
    ivec2(-1,0),
    ivec2(0,-1),
    ivec2(1,1),
    ivec2(-1,1),
    ivec2(1,-1),
    ivec2(-1,-1),
};

const float W[9] = {
    4.0/9.0,
    1.0/9.0,
    1.0/9.0,
    1.0/9.0,
    1.0/9.0,
    1.0/36.0,
    1.0/36.0,
    1.0/36.0,
    1.0/36.0,
};


/*float f_eq(int i, float rho, vec2 p) {
    vec2 u = p / rho;
    float uc = dot(u, c[i]);
    return W[i] * rho * (1.0 + 3. * uc + 4.5 * uc * uc - 1.5 * dot(u,u));
}*/


float f_eq(int i, float rho, vec2 p) {
    vec2 u = p / rho;
    
    return W[i] * rho * (2 - sqrt(1 + 3 * u.x * u.x) ) * (2-sqrt(1+3*u.y*u.y)) * pow((2*u.x + sqrt(1 + 3*u.x*u.x)) / (1-u.x), c[i].x) * pow((2 * u.y + sqrt(1+ 3 * u.y *u.y)) / (1-u.y), c[i].y);
}

const float beta = 0.9995;

void main() {
    float f [N];

    ivec2 dims = imageSize(input_f).xy;

    float rho = 0.0;
    vec2 p = vec2(0);

    if(push_constants.init) {
        vec2 pos = vec2(gl_GlobalInvocationID.xy) / vec2(dims);

        float rho_init = 1.0;
        vec2 p_init = vec2(0.5 * rho_init * sin(pos.x * 3.14159 * 2- 0.03 * sin(pos.y * 3.14159 * 20)) * (pos.y)*(1-pos.y),0);

        for(int i = 0; i < N; i++) {
            f[i] = f_eq(i, rho_init, p_init);

            rho += f[i];
            p += c[i] * f[i];
        }

        if(gl_GlobalInvocationID.xy == uvec2(100,100)) {
            debugPrintfEXT("rho_init = %f, p_init = (%f %f) , rho = %f, p = (%f %f)\n", rho_init, p_init.x, p_init.y, rho, p.x ,p.y);

            for(int i = 0; i < N; i++) {
                debugPrintfEXT("f[%d] = %f\n", i, f[i]);
            }
        }
    }
    else {
        for(int i = 0; i < N; i++) {
            f[i] = imageLoad(input_f, ivec3(gl_GlobalInvocationID.xy, i)).r;

            rho += f[i];
            p += c[i] * f[i];

            
        }

        if(abs(rho) <= 0.001) {
            debugPrintfEXT("rho very small: %f\n", rho);
        }
    }


    for(int i = 0; i < N; i++) {
        float f_next = f[i] + 2 * beta * (f_eq(i, rho, p) - f[i]);

        ivec2 access = (ivec2(gl_GlobalInvocationID.xy) + dims + c[i]) % dims;

        imageStore(output_f, ivec3(access, i), vec4(f_next,0,0,0));
    }

}